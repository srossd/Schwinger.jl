var documenterSearchIndex = {"docs":
[{"location":"man/timeevolution.html#Time-evolution","page":"Time evolution","title":"Time evolution","text":"Schwinger.jl supports time-evolving states using all three backends:\n\nED: Uses Krylov methods from KrylovKit.jl\nITensors: Uses the time-dependent variational principle (TDVP) from ITensorMPS.jl\nMPSKit: Uses TDVP from MPSKit.jl\n\nThe evolve function evolves a state forwards in time, and monitors any given observables. It returns a final state along with a DataFrame of the observables. For example, here is a simulation of flux unwinding.\n\nusing Schwinger, Plots\n\nlat = Lattice(10; F = 1, L = 2, periodic = true)\ngs = groundstate(Hamiltonian(lat; backend=:ED))\n\n_, df = evolve(WilsonLoop(lat; backend=:ED) * gs, 15; \n    nsteps = 30, \n    observable = (ψ, t) -> sum(electricfields(ψ))/10\n)\n\nscatter(df.time, df.observable, xlabel = \"gt\", ylabel = \"Average electric field\", label = \"Schwinger.jl\")\nplot!(0:.1:15, [cos(t/√(π)) for t in 0:.1:15], label = \"Exact\")","category":"section"},{"location":"man/timeevolution.html#Schwinger.evolve","page":"Time evolution","title":"Schwinger.evolve","text":"evolve(state::EDState, t::Real; nsteps::Int = 1, tol = 1E-12, observable = nothing, kwargs...)\n\nEvolve an exact diagonalization state by time t using matrix exponentiation.\n\nArguments\n\nstate::EDState: The state to evolve.\nt::Real: The time to evolve by.\nnsteps::Int = 1: Number of time steps to divide the evolution into.\ntol = 1E-12: Tolerance for the matrix exponentiation.\nobservable::Union{Nothing,Function,Dict} = nothing: Observable(s) to monitor during evolution. Can be a single function (state, t) -> value or a dictionary of name => function pairs.\n\nReturns\n\nEDState: The evolved state.\nobs: Observer object containing the history of observables and metadata.\n\nExamples\n\nevolved_state, obs = evolve(state, 1.0; nsteps=10, observable=s->energy(s))\n\n\n\n\n\nevolve(state::ITensorState, t::Real; nsteps::Int = 1, observable = nothing, kwargs...)\n\nEvolve an ITensor MPS state by imaginary time t using TDVP.\n\nArguments\n\nstate::ITensorState: The state to evolve.\nt::Real: The time to evolve by (will be multiplied by -im for imaginary time evolution).\nnsteps::Int = 1: Number of time steps for the TDVP algorithm.\nobservable::Union{Nothing,Function,Dict} = nothing: Observable(s) to monitor during evolution. Can be a single function (state, t) -> value or a dictionary of name => function pairs.\nkwargs...: Additional keyword arguments passed to the TDVP algorithm.\n\nReturns\n\nITensorState: The evolved state.\nobs: Observer object containing the history of observables and metadata.\n\nNotes\n\nUses ITensors.jl TDVP algorithm.\nTime is tracked as real values (divided by -im) in the observer.\n\n\n\n\n\nevolve(state::MPSKitState, t::Real; nsteps::Int = 1, dt = nothing, observable = nothing, kwargs...)\n\nEvolve an MPSKit MPS state by time t using MPSKit's TDVP algorithm.\n\nArguments\n\nstate::MPSKitState: The state to evolve.\nt::Real: The time to evolve by.\nnsteps::Int = 1: Number of time steps to divide the evolution into.\ndt::Union{Nothing,Real} = nothing: Time step size (currently unused, evolution uses t/nsteps).\nobservable::Union{Nothing,Function,Dict} = nothing: Observable(s) to monitor during evolution. Can be a single function (state, t) -> value or a dictionary of name => function pairs.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nMPSKitState: The evolved state.\nobs: Observer object containing the history of observables and metadata.\n\nNotes\n\nUses MPSKit.jl TDVP algorithm.\nEvolves with imaginary time (-im*t/nsteps).\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#States","page":"States","title":"States","text":"Lattice states in Schwinger.jl are represented by the abstract type SchwingerState, with four concrete types: \n\nBasisState: a state specified by the eigenvalues of occupation operators chi^dagger_nalphachi_nalpha and L_0\nEDState: a linear combination of BasisStates\nITensorState: a matrix product state using ITensorMPS.jl\nMPSKitState: a matrix product state using MPSKit.jl\n\nGiven a state, we can find the expectation values of the occupation operators and electric field operators:\n\nusing Schwinger\nlat = Lattice(6; F = 1, a = 10) # towards the lattice strong coupling limit ga -> infty\ngs = groundstate(Hamiltonian(lat; backend=:ED))\n\noccupations(gs), electricfields(gs)\n\nWe can also evaluate the entanglement entropies of each bisection of the lattice:\n\nusing Schwinger\nlat = Lattice(20; F = 1, )\ngs = groundstate(Hamiltonian(lat; backend=:ITensors))\nentanglements(gs)\n\nWhen using an infinite lattice with MPSKit, we can compute these quantities in the thermodynamic limit.\n\nusing Schwinger\nlat = Lattice(Inf; F = 1, )\ngs = groundstate(Hamiltonian(lat; backend=:MPSKit))\nentanglements(gs)\n\nThe two numbers here correspond to the two possible bisections of the two-site unit cell (corresponding to an odd and an site from the middle of a large finite lattice).\n\nSeveral other useful functions are detailed below.","category":"section"},{"location":"man/states.html#Schwinger.SchwingerState","page":"States","title":"Schwinger.SchwingerState","text":"SchwingerState\n\nAbstract type for Schwinger model states.\n\n\n\n\n\n","category":"type"},{"location":"man/states.html#Schwinger.BasisState","page":"States","title":"Schwinger.BasisState","text":"BasisState(occupations, L0)\n\nA Schwinger model basis state.\n\n\n\n\n\n","category":"type"},{"location":"man/states.html#Schwinger.EDState","page":"States","title":"Schwinger.EDState","text":"EDState(hamiltonian, coeffs)\n\nA Schwinger model state represented as a linear combination of basis states.\n\n\n\n\n\n","category":"type"},{"location":"man/states.html#Schwinger.ITensorState","page":"States","title":"Schwinger.ITensorState","text":"ITensorState(hamiltonian, psi)\n\nA Schwinger model MPS.\n\n\n\n\n\n","category":"type"},{"location":"man/states.html#Schwinger.MPSKitState","page":"States","title":"Schwinger.MPSKitState","text":"MPSKitState(hamiltonian, psi)\n\nA Schwinger model MPS using MPSKit.jl.\n\n\n\n\n\n","category":"type"},{"location":"man/states.html#Schwinger.occupation","page":"States","title":"Schwinger.occupation","text":"occupation(state, site)\n\nReturn the expectations of χ†χ operators of each flavor on a given site.\n\nArguments\n\nstate::ITensorState: Schwinger model state.\nsite::Int: the lattice site.\n\n\n\n\n\noccupation(state, site)\n\nReturn the expectations of χ†χ operators of each flavor on a given site.\n\nArguments\n\nstate::MPSKitState: Schwinger model state.\nsite::Int: the lattice site.\n\n\n\n\n\noccupation(state, site)\n\nReturn the expectations of χ†χ operators of each flavor on a given site.\n\nArguments\n\nstate::BasisState: Schwinger model basis state.\nsite::Int: the lattice site.\n\n\n\n\n\noccupation(state, site)\n\nReturn the expectations of χ†χ operators of each flavor on a given site.\n\nArguments\n\nstate::EDState: Schwinger model basis state.\nsite::Int: the lattice site.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.occupations","page":"States","title":"Schwinger.occupations","text":"occupations(state)\n\nReturn an NxF matrix of the expectations of χ†χ operators on each site.\n\nArguments\n\nstate::ITensorState: Schwinger model state.\n\n\n\n\n\noccupations(state)\n\nReturn an NxF matrix of the expectations of χ†χ operators on each site.\n\nArguments\n\nstate::MPSKitState: Schwinger model state.\n\n\n\n\n\noccupations(state)\n\nReturn an NxF matrix of the expectations of χ†χ operators on each site.\n\nArguments\n\nstate::BasisState: Schwinger model basis state.\n\n\n\n\n\noccupations(state)\n\nReturn an NxF matrix of the expectations of χ†χ operators on each site.\n\nArguments\n\nstate::EDState: Schwinger model basis state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.charge","page":"States","title":"Schwinger.charge","text":"charge(state, site)\n\nReturn the expectation value of the charge operator on site site.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nsite::Int: site.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.charges","page":"States","title":"Schwinger.charges","text":"charges(state)\n\nReturn a list of the expectations of Q operators on each site.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.electricfield","page":"States","title":"Schwinger.electricfield","text":"electricfield(state, link)\n\nReturn the expectation of (L + θ/2π) on the link link.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nlink::Int: link.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.electricfields","page":"States","title":"Schwinger.electricfields","text":"electricfields(state)\n\nReturn a list of the expectations of (L + θ/2π) operators on each link.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.entanglement","page":"States","title":"Schwinger.entanglement","text":"entanglement(state, bisection)\n\nReturn the von Neumann entanglement entropy -tr(ρₐ log(ρₐ)), where a is the subsystem of sites 1..bisection\n\nArguments\n\nstate::EDState: Schwinger model state.\nbisection::Int: bisection index.\n\n\n\n\n\nentanglement(state, bisection)\n\nReturn the von Neumann entanglement entropy -tr(ρₐ log(ρₐ)), where a is the subsystem of sites 1..bisection\n\nArguments\n\nstate::ITensorState: Schwinger model state.\nbisection::Int: bisection index.\n\n\n\n\n\nentanglement(state, bisection)\n\nReturn the von Neumann entanglement entropy -tr(ρₐ log(ρₐ)), where a is the subsystem of sites 1..bisection\n\nArguments\n\nstate::MPSKitState: Schwinger model state.\nbisection::Int: bisection index.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.entanglements","page":"States","title":"Schwinger.entanglements","text":"entanglements(state)\n\nReturn a list of the von Neumann entanglement entropies for each bisection of the lattice.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.energy","page":"States","title":"Schwinger.energy","text":"energy(state)\n\nReturn the expectation value of the Hamiltonian.\n\nArguments\n\nstate::SchwingerState: Schwinger model state (ED, MPS, or MPSKit).\n\n\n\n\n\nenergy(state)\n\nReturn the expectation value of the Hamiltonian.\n\nArguments\n\nstate::BasisState: Schwinger model basis state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.L₀","page":"States","title":"Schwinger.L₀","text":"L₀(state)\n\nReturn the expectation value of L₀.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.scalar","page":"States","title":"Schwinger.scalar","text":"scalar(state)\n\nReturn the expectation value of the scalar condensate, ⟨H_mass⟩/L.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.scalardensity","page":"States","title":"Schwinger.scalardensity","text":"scalardensity(state, site)\n\nReturn the scalar density at site site.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nsite::Int: site.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.scalardensities","page":"States","title":"Schwinger.scalardensities","text":"scalardensities(state)\n\nReturn the list of scalar densities of state on sites 1 through N.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nsite::Int: site.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.pseudoscalar","page":"States","title":"Schwinger.pseudoscalar","text":"pseudoscalar(state)\n\nReturn the expectation value of the pseudoscalar condensate, ⟨H_hoppingmass⟩/L.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.pseudoscalardensity","page":"States","title":"Schwinger.pseudoscalardensity","text":"pseudoscalardensity(state, n)\n\nReturn the pseudoscalar density at site n.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nn::Int: site.\n\n\n\n\n\n","category":"function"},{"location":"man/states.html#Schwinger.pseudoscalardensities","page":"States","title":"Schwinger.pseudoscalardensities","text":"pseudoscalardensities(state)\n\nReturn the list of pseudoscalar densities of state on sites 1 through N.\n\nArguments\n\nstate::SchwingerState: Schwinger model state.\nsite::Int: site.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Operators","page":"Operators","title":"Operators","text":"Operators in Schwinger.jl are represented by the abstract type SchwingerOperator, with three concrete types:\n\nEDOperator: an operator represented as a matrix for its action on a basis of BasisStates\nITensorOperator: a matrix product operator using ITensorMPS.jl\nMPSKitOperator: a matrix product operator using MPSKit.jl","category":"section"},{"location":"man/operators.html#Unified-API","page":"Operators","title":"Unified API","text":"Like the Hamiltonian, other operators can be constructed using the unified API with the backend keyword:\n\nW = WilsonLoop(lattice; backend=:ED)\nW = WilsonLoop(lattice; backend=:ITensors)\nW = WilsonLoop(lattice; backend=:MPSKit)\n\nWe can evaluate the expectation of an operator in a state:\n\nusing Schwinger\nlat = Lattice(10; F = 1, )\ngs = groundstate(Hamiltonian(lat; backend=:ED))\n\nsum(electricfields(gs))/10, expectation(AverageElectricField(lat; backend=:ED), gs)\n\nThis can also be carried out manually by acting on the state with the operator:\n\nusing LinearAlgebra\ndot(gs, AverageElectricField(lat; backend=:ED) * gs)","category":"section"},{"location":"man/operators.html#Exact-diagonalization","page":"Operators","title":"Exact diagonalization","text":"","category":"section"},{"location":"man/operators.html#ITensors-operators","page":"Operators","title":"ITensors operators","text":"","category":"section"},{"location":"man/operators.html#MPSKit-operators","page":"Operators","title":"MPSKit operators","text":"","category":"section"},{"location":"man/operators.html#Schwinger.expectation","page":"Operators","title":"Schwinger.expectation","text":"expectation(op, state)\n\nReturn the expectation value of the operator op in state.\n\nArguments\n\nop::EDOperator`: operator.\nstate::EDState: state.\n\n\n\n\n\nexpectation(op, state)\n\nReturn the expectation value of the operator op in state.\n\nArguments\n\nop::ITensorOperator`: operator.\nstate::ITensorState: state.\n\n\n\n\n\nexpectation(op, state)\n\nReturn the expectation value of the operator op in state.\n\nArguments\n\nop::MPSKitOperator`: operator.\nstate::MPSKitState: state.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.act","page":"Operators","title":"Schwinger.act","text":"act(op, state)\n\nApply the operator op to the state state.\n\nArguments\n\nop::ITensorOperator: operator.\nstate::ITensorState: state.\n\n\n\n\n\nact(op, state)\n\nApply the operator op to the state state.\n\nArguments\n\nop::EDOperator: operator.\nstate::EDState: state.\n\n\n\n\n\nact(op, state)\n\nApply the operator op to the state state.\n\nArguments\n\nop::MPSKitOperator: operator.\nstate::MPSKitState: state.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.EDWilsonLoop","page":"Operators","title":"Schwinger.EDWilsonLoop","text":"wilsonloop(hamiltonian, conjugate = false)\n\nReturns the spatial Wilson loop operator for lattice.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson loop.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.EDWilsonLine","page":"Operators","title":"Schwinger.EDWilsonLine","text":"EDWilsonLine(lattice, conjugate = false, flavor = 1, start = 1, finish = N)\n\nReturns the spatial Wilson line operator for lattice.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson line.\nflavor::Int: Flavor of the Wilson line.\nstart::Int: Starting site of the Wilson line.\nfinish::Int: Finishing site of the Wilson line.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.EDAverageElectricField","page":"Operators","title":"Schwinger.EDAverageElectricField","text":"EDAverageElectricField(lattice; power = 1, L_max = nothing, universe = 0)\n\nConstruct an EDOperator that computes the average electric field (raised to some power).\n\nArguments\n\nlattice::Lattice: The lattice to compute the average electric field on.\npower::Int=1: The power to raise the electric field to.\nL_max::Union{Nothing,Int}=nothing: The maximum absolute value of L₀.\nuniverse::Int=0: The universe to compute the average electric field in.\nsitelist::Union{Nothing,Vector{Int}}=nothing: List of sites to average over.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.ITensorWilsonLoop","page":"Operators","title":"Schwinger.ITensorWilsonLoop","text":"ITensorWilsonLoop(lattice, conjugate = false)\n\nReturns the spatial Wilson loop operator for lattice.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson loop.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.ITensorWilsonLine","page":"Operators","title":"Schwinger.ITensorWilsonLine","text":"ITensorWilsonLine(lattice, conjugate = false, flavor = 1, start = 1, finish = N)\n\nReturns the spatial Wilson line operator for lattice.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson line.\nflavor::Int: Flavor of the Wilson line.\nstart::Int: Starting site of the Wilson line.\nfinish::Int: Finishing site of the Wilson line.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.ITensorAverageElectricField","page":"Operators","title":"Schwinger.ITensorAverageElectricField","text":"ITensorAverageElectricField(lattice; power = 1, L_max = nothing, universe = 0)\n\nConstruct an ITensorOperator that computes the average electric field (raised to some power).\n\nArguments\n\nlattice::Lattice: The lattice to compute the average electric field on.\npower::Int=1: The power to raise the electric field to.\nL_max::Union{Nothing,Int}=nothing: The maximum absolute value of L₀.\nuniverse::Int=0: The universe to compute the average electric field in.\nsitelist::Union{Nothing,Vector{Int}}=nothing: List of sites to average over.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.MPSKitWilsonLoop","page":"Operators","title":"Schwinger.MPSKitWilsonLoop","text":"MPSKitWilsonLoop(lattice, conjugate = false)\n\nReturns the spatial Wilson loop operator for lattice using MPSKit.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson loop.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.MPSKitWilsonLine","page":"Operators","title":"Schwinger.MPSKitWilsonLine","text":"MPSKitWilsonLine(lattice, conjugate = false, flavor = 1, start = 1, finish = N)\n\nReturns the spatial Wilson line operator for lattice using MPSKit.\n\nArguments\n\nlattice::Lattice: lattice.\nconjugate::Bool: Conjugation of the Wilson line.\nflavor::Int: Flavor of the Wilson line.\nstart::Int: Starting site of the Wilson line.\nfinish::Int: Finishing site of the Wilson line.\n\n\n\n\n\n","category":"function"},{"location":"man/operators.html#Schwinger.MPSKitAverageElectricField","page":"Operators","title":"Schwinger.MPSKitAverageElectricField","text":"MPSKitAverageElectricField(lattice; power = 1, L_max = nothing, universe = 0)\n\nConstruct an MPSKitOperator that computes the average electric field (raised to some power).\n\nArguments\n\nlattice::Lattice: The lattice to compute the average electric field on.\npower::Int=1: The power to raise the electric field to.\nuniverse::Int=0: The universe to compute the average electric field in.\nsitelist::Union{Nothing,Vector{Int}}=nothing: List of sites to average over.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Schwinger.jl","page":"Index","title":"Schwinger.jl","text":"A package for working with the Hamiltonian lattice Schwinger model.","category":"section"},{"location":"index.html#Table-of-contents","page":"Index","title":"Table of contents","text":"Pages = [\"home.md\", \"man/lattices.md\", \"man/hamiltonian.md\", \"man/states.md\", \"man/operators.md\", \"man/timeevolution.md\"]\nDepth = 4","category":"section"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"To install Schwinger.jl, use the following command in the Julia REPL:\n\nusing Pkg\nPkg.add(\"https://github.com/srossd/Schwinger.jl\")","category":"section"},{"location":"index.html#Key-Features","page":"Index","title":"Key Features","text":"Schwinger.jl provides functions for computing the following properties of the Hamiltonian lattice Schwinger model:\n\nEnergy levels: Ground state, energy gap, or higher excited states.\nCorrelators: Expectation values of various operators in the ground state (or other states).\nTime evolution: Action of time evolution on a given initial state.\n\nAll of these features are implemented using three backends: exact diagonalization (ED), ITensors MPO/MPS, and MPSKit MPO/MPS. A unified API allows seamless switching between backends.","category":"section"},{"location":"index.html#Usage-Example","page":"Index","title":"Usage Example","text":"Here is a basic example of how to use Schwinger.jl to calculate the average electric field in the one-flavor Schwinger model at mg = 01 as a function of theta. Note that the mass shift (see here) is included by default.\n\nusing Schwinger\nusing Base.MathConstants\nusing Plots\n\nfunction avgE(θ2π, m, shift = true)\n    lat = shift ? \n        Lattice(10; F = 1, θ2π = θ2π, m = m, periodic = true) : \n        Lattice(10; F = 1, θ2π = θ2π, mlat = m, periodic = true)\n    # Using unified API with ED backend\n    gs = groundstate(Hamiltonian(lat; backend=:ED))\n    return real(expectation(AverageElectricField(lat; backend=:ED), gs))\nend\n\nm = 0.05\nθ2πs = 0:0.025:1\navgEs_shift = map(x -> avgE(x, m), θ2πs)\navgEs_noshift = map(x -> avgE(x, m, false), θ2πs)\n\n# See eq (24) of https://arxiv.org/abs/2206.05308\nperturbative = [(exp(γ)/√(π))*m*sin(2π*θ2π) - \n    (8.9139*exp(2γ)/(4π))*(m^2)*sin(4π*θ2π) for θ2π in θ2πs]\n\nscatter(θ2πs, avgEs_noshift, \n    label=\"Without mass shift\", \n    xlabel=\"θ/2π\", \n    ylabel=\"Average Electric Field\", \n    color=\"lightblue\")\nscatter!(θ2πs, avgEs_shift, \n    label=\"With mass shift\", \n    xlabel=\"θ/2π\", \n    ylabel=\"Average Electric Field\", \n    legend=:topright, \n    color=:orange)\nplot!(θ2πs, perturbative, \n    label=\"Perturbative\", \n    color=:black)\n\nHere is an example of calculating the expectation value of the square of the mean electric field in the two-flavor Schwinger model at theta = pi, for a four-site periodic lattice, giving a very rough look at the phase diagram.\n\nusing Schwinger\nusing Plots\n\nfunction avgE2(m1, m2)\n    lat = Lattice(4; F = 2, θ2π = 0.5, m = [m1, m2], periodic = true)\n    gs = groundstate(Hamiltonian(lat; backend=:ED))\n    return real(expectation(AverageElectricField(lat; backend=:ED, power=2), gs))\nend\n\nms = -1:0.05:1\nheatmap(ms, ms, avgE2, xlabel = \"m₁/g\", ylabel = \"m₂/g\", c = :berlin)","category":"section"},{"location":"man/hamiltonian.html#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"The Hamiltonian for the lattice Schwinger model is\n\nbeginsplit\nH = frac(qg)^2 a2sum_n=1^N left(L_n + fractheta2piright)^2 - fraci2asum_n=1^Nsum_alpha=1^F left(chi^dagger_nalpha chi_n+1alpha - chi^dagger_n+1alpha chi_nalpharight) \n+underbraceleft(m - frac(qg)^2 F a8right)_m_textlatsum_n=1^N sum_alpha=1^F (-1)^n chi^dagger_nalpha chi_nalpha + m sum_n=1^Nsum_alpha=1^F (-1)^n+1left(chi^dagger_n-1alphachi_nalpha + chi^dagger_n+1alphachi_nalpharight)\nendsplit\n\nThis is supplemented by the Gauss law\n\nL_n = L_n-1 + Q_n qquad Q_n equiv qleft(sum_alpha=1^F chi^dagger_nalpha chi_nalpha - begincases F  ntext odd  0  ntext even endcasesright)\n\nIn Schwinger.jl, the Hamiltonian can be constructed using three computational backends:\n\nExact Diagonalization (ED): Uses sparse matrices for small systems\nITensors: Uses MPO/MPS via ITensors.jl and ITensorMPS.jl\nMPSKit: Uses MPO/MPS via MPSKit.jl","category":"section"},{"location":"man/hamiltonian.html#Unified-API","page":"Hamiltonian","title":"Unified API","text":"The unified API allows you to construct operators using any backend by specifying the backend keyword argument:\n\n# Using symbols\nH = Hamiltonian(lattice; backend=:ED)\nH = Hamiltonian(lattice; backend=:ITensors)  # Default\nH = Hamiltonian(lattice; backend=:MPSKit)\n\n# Using backend types directly\nH = Hamiltonian(lattice; backend=EDBackend())\nH = Hamiltonian(lattice; backend=ITensorsBackend())\nH = Hamiltonian(lattice; backend=MPSKitBackend())\n\nYou can also set a default backend programmatically:\n\nset_default_backend(:MPSKit)\nH = Hamiltonian(lattice)  # Now uses MPSKit by default","category":"section"},{"location":"man/hamiltonian.html#Exact-diagonalization","page":"Hamiltonian","title":"Exact diagonalization","text":"When using exact diagonalization, Schwinger.jl constructs a basis of states that diagonalize the operators chi^dagger_nalpha chi_nalpha and L_0. It then builds a sparse matrix for the Hamiltonian acting on this basis.\n\nusing Schwinger\nlat = Lattice(12; F = 1);\nham = Hamiltonian(lat; backend=:ED);\n\nham.matrix\n\nYou can also use the backend-specific constructor EDHamiltonian for backward compatibility.\n\nWhen q  1, the universe (i.e., the allowed values of L_n modulo q) can be specified; the default value is 0. When the lattice is periodic, the maximum absolute value of L_0 can be set using L_max; the default value is 3.\n\nUsing Arpack.jl, Schwinger.jl can find the lowest eigenstates of a Hamiltonian.\n\nusing Schwinger\nlat = Lattice(10; F = 1, periodic = true);\nham = Hamiltonian(lat; backend=:ED);\n\nmap(energy, loweststates(ham, 5))","category":"section"},{"location":"man/hamiltonian.html#Matrix-product-operators","page":"Hamiltonian","title":"Matrix product operators","text":"For larger lattice sizes where exact diagonalization is infeasible, Schwinger.jl can construct a matrix product operator representation of the Hamiltonian using two backends:\n\nITensors: Uses ITensors.jl and ITensorMPS.jl\nMPSKit: Uses MPSKit.jl\n\nusing Schwinger\nlat = Lattice(10; F = 1);\n\n# Compare energy gaps across backends\n[\n    energygap(Hamiltonian(lat; backend=:ED)),\n    energygap(Hamiltonian(lat; backend=:ITensors)),\n    energygap(Hamiltonian(lat; backend=:MPSKit))\n]","category":"section"},{"location":"man/hamiltonian.html#ITensors-Backend","page":"Hamiltonian","title":"ITensors Backend","text":"","category":"section"},{"location":"man/hamiltonian.html#MPSKit-Backend","page":"Hamiltonian","title":"MPSKit Backend","text":"","category":"section"},{"location":"man/hamiltonian.html#Schwinger.EDHamiltonian","page":"Hamiltonian","title":"Schwinger.EDHamiltonian","text":"EDHamiltonian(lattice) Computes the Hamiltonian for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.EDGaugeKinetic","page":"Hamiltonian","title":"Schwinger.EDGaugeKinetic","text":"EDGaugeKinetic(lattice) Computes the gauge kinetic operator ∑(Lₙ+θ/2π)² for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.EDHopping","page":"Hamiltonian","title":"Schwinger.EDHopping","text":"EDHopping(lattice) Computes the hopping term -i ∑(χ†ₙ χₙ₊₁ - χ†ₙ₊₁ χₙ) for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.EDMass","page":"Hamiltonian","title":"Schwinger.EDMass","text":"EDMass(lattice) Computes the mass operator ∑ (-1)ⁿ χ†ₙχₙ for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.EDHoppingMass","page":"Hamiltonian","title":"Schwinger.EDHoppingMass","text":"EDHoppingMass(lattice) Computes the hopping-type mass term i/2 ∑(-1)^n (χ†ₙ₊₁ χₙ + χ†ₙ₋₁ χₙ) for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.ITensorHamiltonian","page":"Hamiltonian","title":"Schwinger.ITensorHamiltonian","text":"MPOHamiltonian(lattice)\n\nComputes the MPO Hamiltonian for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.ITensorGaugeKinetic","page":"Hamiltonian","title":"Schwinger.ITensorGaugeKinetic","text":"MPOGaugeKinetic(lattice)\n\nComputes the MPO gauge kinetic operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.ITensorHopping","page":"Hamiltonian","title":"Schwinger.ITensorHopping","text":"MPOHopping(lattice)\n\nComputes the MPO hopping operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.ITensorMass","page":"Hamiltonian","title":"Schwinger.ITensorMass","text":"MPOMass(lattice)\n\nComputes the MPO mass operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.ITensorHoppingMass","page":"Hamiltonian","title":"Schwinger.ITensorHoppingMass","text":"MPOHoppingMass(lattice)\n\nComputes the MPO hopping-mass operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.MPSKitHamiltonian","page":"Hamiltonian","title":"Schwinger.MPSKitHamiltonian","text":"MPSKitHamiltonian(lattice)\n\nComputes the MPSKit Hamiltonian for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.MPSKitGaugeKinetic","page":"Hamiltonian","title":"Schwinger.MPSKitGaugeKinetic","text":"MPSKitGaugeKinetic(lattice)\n\nComputes the MPSKit gauge kinetic operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.MPSKitHopping","page":"Hamiltonian","title":"Schwinger.MPSKitHopping","text":"MPSKitHopping(lattice)\n\nComputes the MPSKit hopping operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.MPSKitMass","page":"Hamiltonian","title":"Schwinger.MPSKitMass","text":"MPSKitMass(lattice)\n\nComputes the MPSKit mass operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/hamiltonian.html#Schwinger.MPSKitHoppingMass","page":"Hamiltonian","title":"Schwinger.MPSKitHoppingMass","text":"MPSKitHoppingMass(lattice)\n\nComputes the MPSKit hopping-mass operator for the Schwinger model.\n\nArguments\n\nlattice::Lattice: Schwinger model lattice.\n\n\n\n\n\n","category":"function"},{"location":"man/lattices.html#Lattices","page":"Lattices","title":"Lattices","text":"Any calculation in Schwinger.jl will start with a Lattice. The only required parameter is the number of sites N. For any backend, N can be an even integer; for MPSKit, it can also be Inf. Other parameters can be specified as keyword arguments:\n\nF: number of flavors (default 1)\nperiodic: whether the lattice is periodic (default false)\nq: the integer charge of the fermions (default 1)\nθ2π: the theta-angle divided by 2pi (default 0)\na: the lattice spacing in coupling units (default 1)\nm: the physical mass (in coupling units); the mass shift is applied automatically. (default 0)\nmlat: the mass parameter in the Hamiltonian (default -q^2 * F * a/8)\nmprime: the coefficient of the hopping-type mass term (default 0)\n\nThe sites of the lattice are indexed from 1 to N. The electric field operators are laid out as in the diagram below.\n\n(Image: A Schwinger model lattice)\n\nHere alpha = 1ldotsF is a flavor index.\n\nFor details of how these parameters enter into the Hamiltonian, see here.","category":"section"},{"location":"man/lattices.html#Schwinger.Lattice","page":"Lattices","title":"Schwinger.Lattice","text":"Lattice(;kwargs...)\n\nConstructs a Lattice for the Schwinger model.\n\nArguments\n\nN::Union{Integer,Inf}: Number of sites (use Inf for infinite lattices).\nF::Int=1: Number of flavors.\nperiodic::Bool=false: Whether the lattice is periodic.\nq::Int=1: Charge.\nL::Union{Nothing,Real}=nothing: Length of the lattice.\na::Union{Nothing,Real}=nothing: Lattice spacing.\nm::Union{Real,AbstractVector{<:Real},AbstractArray{<:Real,2}}=0.: Mass parameter.\nmlat::Union{Nothing,Real,AbstractVector{<:Real},AbstractArray{<:Real,2}}=nothing: Lattice mass parameter.\nmprime::Union{Real,AbstractVector{<:Real},AbstractArray{<:Real,2}}=0.: Hopping mass parameter.\nθ2π::Union{Real,NTuple{N,Real}}=0.: Theta angle.\n\nReturns\n\nA Lattice object.\n\n\n\n\n\n","category":"type"}]
}
